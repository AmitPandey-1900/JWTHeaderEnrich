import java.io.FileWriter;
import java.io.IOException;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ResourceLoader;
import org.springframework.security.oauth2.client.OAuth2ClientContext;
import org.springframework.security.oauth2.common.DefaultOAuth2AccessToken;
import org.springframework.security.oauth2.common.exceptions.InvalidTokenException;
import org.springframework.security.oauth2.common.util.AccessTokenPayload;
import org.springframework.security.oauth2.provider.token.ResourceVerifier;
import org.springframework.security.oauth2.provider.token.TokenVerifier;
import org.springframework.stereotype.Service;
import org.springframework.util.FileCopyUtils;
import org.springframework.util.ResourceUtils;

import com.fasterxml.jackson.databind.ObjectMapper; // Optional for parsing expiration claim

@Service
public class JWTTokenService {

    @Autowired
    private OAuth2ClientContext oauth2ClientContext;

    @Autowired
    private ResourceLoader resourceLoader; // For resolving file path

    @Value("${spring.security.oauth2.client.registration.auth0.client-id}")
    private String clientId;

    @Value("${data.file.path}") // Path to write token to disk
    private String tokenFilePath;

    @Value("${jwt.token.expiration.buffer}") // Buffer before expiry (seconds)
    private Long expirationBufferSeconds;

    private volatile String cachedToken;
    private volatile long lastTokenFetchTimeMillis;

    public synchronized String getUnexpiredToken() throws IOException {
        long currentTimeMillis = System.currentTimeMillis();

        if (cachedToken != null && (currentTimeMillis - lastTokenFetchTimeMillis) < TimeUnit.SECONDS.toMillis(expirationBufferSeconds)) {
            // Check token validity before returning from cache
            if (isValidToken(cachedToken)) {
                return cachedToken;
            }
        }

        fetchAndStoreToken();
        return cachedToken;
    }

    private void fetchAndStoreToken() throws IOException {
        AuthorizedClientServiceOAuth2AccessToken accessToken = oauth2ClientContext.getAccessToken();
        if (accessToken == null) {
            throw new RuntimeException("No access token available from OAuth2 client context");
        }

        cachedToken = accessToken.getTokenValue();
        lastTokenFetchTimeMillis = System.currentTimeMillis();

        // Write token to disk (using Spring's ResourceLoader)
        resourceLoader.getResource(tokenFilePath).createFileFromContent(cachedToken);
    }

    private boolean isValidToken(String token) {
        try {
            // Verify token signature using Spring Security's TokenVerifier (optional)
            TokenVerifier verifier = new DefaultTokenVerifier("YOUR_AUTH0_DOMAIN"); // Replace with your domain
            AccessTokenPayload payload = verifier.decode(token);
            return true;
        } catch (InvalidTokenException e) {
            return false;
        }

        // Optional: Parse expiration claim for verification (using Jackson ObjectMapper)
        // ObjectMapper mapper = new ObjectMapper();
        // JsonNode node = mapper.readValue(token, JsonNode.class);
        // Long exp = node.get("exp").asLong(); // Assuming 'exp' claim exists
        // return exp > (System.currentTimeMillis() / 1000); // Convert to seconds
    }
}
